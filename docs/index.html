<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>The luakeys package</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>luakeys</h1>


<h2>Contents</h2>
<ul>
<li><a href="#Local_Functions">Local Functions</a></li>
<li><a href="#Convert_back_to_strings">Convert back to strings </a></li>
<li><a href="#Class_string">Class string </a></li>
<li><a href="#Parser___Lpeg_related">Parser / Lpeg related </a></li>
<li><a href="#Store_results">Store results </a></li>
</ul>


<h2>Modules</h2>
<ul class="nowrap">
  <li><strong>luakeys</strong></li>
</ul>

</div>

<div id="content">

<h1>Module <code>luakeys</code></h1>
<p>Merge two tables into the first specified table.</p>
<p> The <code>merge_tables</code> function copies keys from the <code>source</code> table
 to the <code>target</code> table. It returns the target table.</p>

<p> https://stackoverflow.com/a/1283608/10193818</p>


<h2><a href="#Local_Functions">Local Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#clone_table">clone_table (source)</a></td>
	<td class="summary">Clone a table, i.e.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#remove_from_table">remove_from_table (source, value)</a></td>
	<td class="summary">Remove an element from a table.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get_table_keys">get_table_keys (source)</a></td>
	<td class="summary">

</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get_table_size">get_table_size (value)</a></td>
	<td class="summary">Get the size of a table <code>{ one = &apos;one&apos;, &apos;two&apos;, &apos;three&apos; }</code> = 3.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get_array_size">get_array_size (value)</a></td>
	<td class="summary">Get the size of an array like table, for example <code>{ &apos;one&apos;, &apos;two&apos;,
  &apos;three&apos; }</code> = 3.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#scan_oarg">scan_oarg (initial_delimiter, end_delimiter)</a></td>
	<td class="summary">Scan for an optional argument.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#throw_error">throw_error (message, help)</a></td>
	<td class="summary">

</td>
	</tr>
</table>
<h2><a href="#Convert_back_to_strings">Convert back to strings </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#render">render (result)</a></td>
	<td class="summary">The function <code>render(tbl)</code> reverses the function
 <code>parse(kv_string)</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#stringify">stringify (result, for_tex)</a></td>
	<td class="summary">The function <code>stringify(tbl, for_tex)</code> converts a Lua table into a
 printable string.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#debug">debug (result)</a></td>
	<td class="summary">The function <code>debug(result)</code> pretty prints a Lua table to standard
   output (stdout).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#main">main ()</a></td>
	<td class="summary">

</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#default_opts">default_opts</a></td>
	<td class="summary">The default options.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#throw_error">throw_error (error_code, args)</a></td>
	<td class="summary">

</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#replace_args">replace_args (message, args)</a></td>
	<td class="summary">

</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#replace_args_in_list">replace_args_in_list (list, args)</a></td>
	<td class="summary">

</td>
	</tr>
</table>
<h2><a href="#Class_string">Class string </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#string.normalize_opts">string.normalize_opts (opts)</a></td>
	<td class="summary">Normalize the parse options.</td>
	</tr>
</table>
<h2><a href="#Parser___Lpeg_related">Parser / Lpeg related </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#generate_parser">generate_parser (initial_rule, opts)</a></td>
	<td class="summary">Generate the PEG parser using Lpeg.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#ws">ws (match)</a></td>
	<td class="summary">Match literal string surrounded by whitespace</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#capture_dimension">capture_dimension (input)</a></td>
	<td class="summary">Convert a dimension to an normalized dimension string or an
 integer in the scaled points format.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#add_to_table">add_to_table (result, arg1, arg2)</a></td>
	<td class="summary">Add values to a table in two modes:</p>

<p> Key-value pair:</p>

<p> If <code>arg1</code> and <code>arg2</code> are not nil, then <code>arg1</code> is the key and <code>arg2</code> is the
 value of a new table entry.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#apply_definitions">apply_definitions (defs, opts, input, output, unknown, key_path, input_root)</a></td>
	<td class="summary">Apply the key-value-pair definitions (defs) on an input table in a
 recursive fashion.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#input">input</a></td>
	<td class="summary">standalone values are removed.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#parse">parse (kv_string, opts)</a></td>
	<td class="summary">Parse a LaTeX/TeX style key-value string into a Lua table.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#apply_opts">apply_opts (result, opts)</a></td>
	<td class="summary">Normalize the result table of the LPeg parser.</td>
	</tr>
</table>
<h2><a href="#Store_results">Store results </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#result_store">result_store</a></td>
	<td class="summary">A table to store parsed key-value results.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#print_names">print_names (from)</a></td>
	<td class="summary">This function is used in the documentation.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#opts">opts</a></td>
	<td class="summary">

</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#stringify">stringify</a></td>
	<td class="summary">

</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#parse">parse</a></td>
	<td class="summary">

</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#render">render</a></td>
	<td class="summary">

</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#debug">debug</a></td>
	<td class="summary">

</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#save">save (identifier, result)</a></td>
	<td class="summary">The function <code>save(identifier, result): void</code> saves a result (a
  table from a previous run of <a href="index.html#parse">parse</a>) under an identifier.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get">get (identifier)</a></td>
	<td class="summary">The function <code>get(identifier): table</code> retrieves a saved result
  from the result store.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Local_Functions"></a>Local Functions</h2>

    <dl class="function">
    <dt>
    <a name = "clone_table"></a>
    <strong>clone_table (source)</strong>
    </dt>
    <dd>
    Clone a table, i.e.  make a deep copy of the source table.</p>

<p>http://lua-users.org/wiki/CopyTable


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">source</span>
         table # The source table to be cloned.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        table # A deep copy of the source table.
    </ol>




</dd>
    <dt>
    <a name = "remove_from_table"></a>
    <strong>remove_from_table (source, value)</strong>
    </dt>
    <dd>
    Remove an element from a table.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">source</span>
         table
        </li>
        <li><span class="parameter">value</span>
         any
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        any|nil
    </ol>




</dd>
    <dt>
    <a name = "get_table_keys"></a>
    <strong>get_table_keys (source)</strong>
    </dt>
    <dd>





    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">source</span>
         table
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        table # An array table with the sorted key names.
    </ol>




</dd>
    <dt>
    <a name = "get_table_size"></a>
    <strong>get_table_size (value)</strong>
    </dt>
    <dd>
    Get the size of a table <code>{ one = &apos;one&apos;, &apos;two&apos;, &apos;three&apos; }</code> = 3.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">value</span>
         any # A table or any input.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        number # The size of the array like table. 0 if the input is no table or the table is empty.
    </ol>




</dd>
    <dt>
    <a name = "get_array_size"></a>
    <strong>get_array_size (value)</strong>
    </dt>
    <dd>
    Get the size of an array like table, for example <code>{ &apos;one&apos;, &apos;two&apos;,
  &apos;three&apos; }</code> = 3.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">value</span>
         any # A table or any input.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        number # The size of the array like table. 0 if the input is no table or the table is empty.
    </ol>




</dd>
    <dt>
    <a name = "scan_oarg"></a>
    <strong>scan_oarg (initial_delimiter, end_delimiter)</strong>
    </dt>
    <dd>
    Scan for an optional argument.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">initial_delimiter</span>
        ? string # The character that marks the beginning of an optional argument (by default <code>[</code>).
        </li>
        <li><span class="parameter">end_delimiter</span>
        ? string # The character that marks the end of an optional argument (by default <code>]</code>).
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string|nil # The string that was enclosed by the delimiters. The delimiters themselves are not returned.
    </ol>




</dd>
    <dt>
    <a name = "throw_error"></a>
    <strong>throw_error (message, help)</strong>
    </dt>
    <dd>





    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">message</span>
         string
        </li>
        <li><span class="parameter">help</span>
        ? table
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header "><a name="Convert_back_to_strings"></a>Convert back to strings </h2>

    <dl class="function">
    <dt>
    <a name = "render"></a>
    <strong>render (result)</strong>
    </dt>
    <dd>
    The function <code>render(tbl)</code> reverses the function
 <code>parse(kv_string)</code>.  It takes a Lua table and converts this table
 into a key-value string. The resulting string usually has a
 different order as the input table. In Lua only tables with
 1-based consecutive integer keys (a.k.a. array tables) can be
 parsed in order.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">result</span>
         table # A table to be converted into a key-value string.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string # A key-value string that can be passed to a TeX macro.
    </ol>




</dd>
    <dt>
    <a name = "stringify"></a>
    <strong>stringify (result, for_tex)</strong>
    </dt>
    <dd>
    The function <code>stringify(tbl, for_tex)</code> converts a Lua table into a
 printable string.  Stringify a table means to convert the table into
 a string. This function is used to realize the <a href="index.html#debug">debug</a> function.
 <code>stringify(tbl, true)</code> (<code>for_tex = true</code>) generates a string which
 can be embeded into TeX documents. The macro <code>\luakeysdebug{}</code> uses
 this option. <code>stringify(tbl, false)</code> or <code>stringify(tbl)</code> generate a
 string suitable for the terminal.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">result</span>
         table # A table to stringify.
        </li>
        <li><span class="parameter">for_tex</span>
        ? boolean # Stringify the table into a text string that can be embeded inside a TeX document via tex.print(). Curly braces and whites spaces are escaped.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string
    </ol>


    <h3>See also:</h3>
    <ul>
    </ul>


</dd>
    <dt>
    <a name = "debug"></a>
    <strong>debug (result)</strong>
    </dt>
    <dd>
    The function <code>debug(result)</code> pretty prints a Lua table to standard
   output (stdout).  It is a utility function that can be used to
   debug and inspect the resulting Lua table of the function
   <a href="index.html#parse">parse</a>. You have to compile your TeX document in a console to
   see the terminal output.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">result</span>
         table # A table to be printed to standard output for debugging purposes.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "main"></a>
    <strong>main ()</strong>
    </dt>
    <dd>






    <h3>Returns:</h3>
    <ol>

        table # The public interface of the module.
    </ol>




</dd>
    <dt>
    <a name = "default_opts"></a>
    <strong>default_opts</strong>
    </dt>
    <dd>
    The default options.







</dd>
    <dt>
    <a name = "throw_error"></a>
    <strong>throw_error (error_code, args)</strong>
    </dt>
    <dd>





    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">error_code</span>
         string
        </li>
        <li><span class="parameter">args</span>
        ? table
        </li>
    </ul>





</dd>
    <dt>
    <a name = "replace_args"></a>
    <strong>replace_args (message, args)</strong>
    </dt>
    <dd>





    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">message</span>
         string
        </li>
        <li><span class="parameter">args</span>
         table
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string
    </ol>




</dd>
    <dt>
    <a name = "replace_args_in_list"></a>
    <strong>replace_args_in_list (list, args)</strong>
    </dt>
    <dd>





    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">list</span>
         table
        </li>
        <li><span class="parameter">args</span>
         table
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        table
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="Class_string"></a>Class string </h2>

    <dl class="function">
    <dt>
    <a name = "string.normalize_opts"></a>
    <strong>string.normalize_opts (opts)</strong>
    </dt>
    <dd>
    Normalize the parse options.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">opts</span>
        ? table # Options in a raw format. The table may be empty or some keys are not set.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        table
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="Parser___Lpeg_related"></a>Parser / Lpeg related </h2>

    <dl class="function">
    <dt>
    <a name = "generate_parser"></a>
    <strong>generate_parser (initial_rule, opts)</strong>
    </dt>
    <dd>

<p>Generate the PEG parser using Lpeg. </p>

<p> Explanations of some LPeg notation forms:</p>

<ul>
    <li><p><code>patt ^ 0</code> = <code>expression *</code></p></li>
    <li><p><code>patt ^ 1</code> = <code>expression +</code></p></li>
    <li><p><code>patt ^ -1</code> = <code>expression ?</code></p></li>
    <li><p><code>patt1 * patt2</code> = <code>expression1 expression2</code>: Sequence</p></li>
    <li><p><code>patt1 + patt2</code> = <code>expression1 / expression2</code>: Ordered choice</p></li>
    <li><p><a href="https://tug.or-g/TUGboat/tb40-2/tb125menke-Patterndf">TUGboat article: Parsing complex data formats in LuaTEX with LPEG</a></p></li>
</ul>




    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">initial_rule</span>
         string # The name of the first rule of the grammar table passed to the <code>lpeg.P(attern)</code> function (e. g. <code>list</code>, <code>number</code>).
        </li>
        <li><span class="parameter">opts</span>
        ? table # Whether the dimensions should be converted to scaled points (by default <code>false</code>).
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        userdata # The parser.
    </ol>




</dd>
    <dt>
    <a name = "ws"></a>
    <strong>ws (match)</strong>
    </dt>
    <dd>
    Match literal string surrounded by whitespace


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">match</span>



        </li>
    </ul>





</dd>
    <dt>
    <a name = "capture_dimension"></a>
    <strong>capture_dimension (input)</strong>
    </dt>
    <dd>
    Convert a dimension to an normalized dimension string or an
 integer in the scaled points format.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">input</span>
         string
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        integer|string # A dimension as an integer or a dimension string.
    </ol>




</dd>
    <dt>
    <a name = "add_to_table"></a>
    <strong>add_to_table (result, arg1, arg2)</strong>
    </dt>
    <dd>
    Add values to a table in two modes:</p>

<p> Key-value pair:</p>

<p> If <code>arg1</code> and <code>arg2</code> are not nil, then <code>arg1</code> is the key and <code>arg2</code> is the
 value of a new table entry. </p>

<p> Indexed value:</p>

<p> If <code>arg2</code> is nil, then <code>arg1</code> is the value and is added as an indexed
 (by an integer) value.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">result</span>
         table # The result table to which an additional key-value pair or value should to be added
        </li>
        <li><span class="parameter">arg1</span>
         any # The key or the value.
        </li>
        <li><span class="parameter">arg2</span>
        ? any # Always the value.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        table # The result table to which an additional key-value pair or value has been added.
    </ol>




</dd>
    <dt>
    <a name = "apply_definitions"></a>
    <strong>apply_definitions (defs, opts, input, output, unknown, key_path, input_root)</strong>
    </dt>
    <dd>
    Apply the key-value-pair definitions (defs) on an input table in a
 recursive fashion.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">defs</span>
         table # A table containing all definitions.
        </li>
        <li><span class="parameter">opts</span>
         table # The parse options table.
        </li>
        <li><span class="parameter">input</span>
         table # The current input table.
        </li>
        <li><span class="parameter">output</span>
         table # The current output table.
        </li>
        <li><span class="parameter">unknown</span>
         table # Always the root unknown table.
        </li>
        <li><span class="parameter">key_path</span>
         table # An array of key names leading to the current
        </li>
        <li><span class="parameter">input_root</span>
         table # The root input table input and output table.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "input"></a>
    <strong>input</strong>
    </dt>
    <dd>
    standalone values are removed.
 For some callbacks and the third return value of parse, we
 need an unchanged raw result from the parse function.







</dd>
    <dt>
    <a name = "parse"></a>
    <strong>parse (kv_string, opts)</strong>
    </dt>
    <dd>
    Parse a LaTeX/TeX style key-value string into a Lua table.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">kv_string</span>
         string # A string in the TeX/LaTeX style key-value format as described above.
        </li>
        <li><span class="parameter">opts</span>
        ? table # A table containing options.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        table result # The final result of all individual parsing and normalization steps.</li>
        <li>
        table unknown # A table with unknown, undefinied key-value pairs.</li>
        <li>
        table raw # The unprocessed, raw result of the LPeg parser.</li>
    </ol>




</dd>
    <dt>
    <a name = "apply_opts"></a>
    <strong>apply_opts (result, opts)</strong>
    </dt>
    <dd>
    Normalize the result table of the LPeg parser.  This normalization
  tasks are performed on the raw input table coming directly from
  the PEG parser:


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">result</span>
         table # The raw input table coming directly from the PEG parser
        </li>
        <li><span class="parameter">opts</span>
         table # Some options.
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header "><a name="Store_results"></a>Store results </h2>

    <dl class="function">
    <dt>
    <a name = "result_store"></a>
    <strong>result_store</strong>
    </dt>
    <dd>
    A table to store parsed key-value results.







</dd>
    <dt>
    <a name = "print_names"></a>
    <strong>print_names (from)</strong>
    </dt>
    <dd>
    This function is used in the documentation.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">from</span>
         string # A key in the namespace table, either <a href="index.html#opts">opts</a>, <code>hook</code> or <code>attrs</code>.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "opts"></a>
    <strong>opts</strong>
    </dt>
    <dd>








    <h3>See also:</h3>
    <ul>
         <a href="index.html#default_opts">default_opts</a>
    </ul>


</dd>
    <dt>
    <a name = "stringify"></a>
    <strong>stringify</strong>
    </dt>
    <dd>








    <h3>See also:</h3>
    <ul>
    </ul>


</dd>
    <dt>
    <a name = "parse"></a>
    <strong>parse</strong>
    </dt>
    <dd>








    <h3>See also:</h3>
    <ul>
         <a href="index.html#parse">parse</a>
    </ul>


</dd>
    <dt>
    <a name = "render"></a>
    <strong>render</strong>
    </dt>
    <dd>








    <h3>See also:</h3>
    <ul>
    </ul>


</dd>
    <dt>
    <a name = "debug"></a>
    <strong>debug</strong>
    </dt>
    <dd>








    <h3>See also:</h3>
    <ul>
    </ul>


</dd>
    <dt>
    <a name = "save"></a>
    <strong>save (identifier, result)</strong>
    </dt>
    <dd>
    The function <code>save(identifier, result): void</code> saves a result (a
  table from a previous run of <a href="index.html#parse">parse</a>) under an identifier.
  Therefore, it is not necessary to pollute the global namespace to
  store results for the later usage.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">identifier</span>
         string # The identifier under which the result is saved.
        </li>
        <li><span class="parameter">result</span>
         table # A result to be stored and that was created by the key-value parser.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "get"></a>
    <strong>get (identifier)</strong>
    </dt>
    <dd>
    The function <code>get(identifier): table</code> retrieves a saved result
  from the result store.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">identifier</span>
         string # The identifier under which the result was saved.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        table
    </ol>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2022-12-31 09:31:35 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
