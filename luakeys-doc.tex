\documentclass{ltxdoc}

\usepackage{hyperref}
\EnableCrossrefs
\CodelineIndex
\RecordChanges

\usepackage{mdframed}
\usepackage{minted}
\usepackage{luakeys-debug}
\usepackage{multicol}
\usepackage{luacode}
\usepackage{syntax}
\usemintedstyle{friendly}
\BeforeBeginEnvironment{minted}{\begin{mdframed}}
\AfterEndEnvironment{minted}{\end{mdframed}}
\setminted{
  breaklines=true,
  fontsize=\footnotesize,
}
\def\lua#1{\mintinline{lua}|#1|}
\def\latex#1{\mintinline{latex}|#1|}

\def\InputLatexExample#1{
  \inputminted[linenos=true]{latex}{examples/#1}
}

\NewDocumentCommand { \InputLuaExample } { O{} m } {
  \begin{mdframed}
  \inputminted[linenos=false,#1]{lua}{examples/#2}
  \end{mdframed}
}

\begin{document}

\providecommand*{\url}{\texttt}

\title{The \textsf{luakeys} package}
\author{%
  Josef Friedrich\\%
  \url{josef@friedrich.rocks}\\%
  \href{https://github.com/Josef-Friedrich/luakeys}{github.com/Josef-Friedrich/luakeys}%
}
\date{v0.5 from 2022/04/04}

\maketitle

\vfill

\InputLuaExample[firstline=4,lastline=7]{first-page.lua}

\noindent
Result:

\begin{center}
\begin{minted}{lua}
{
  ['level1'] = {
    ['level2'] = {
      ['naked'] = true,
      ['dim'] = 1864679,
      ['bool'] = false,
      ['num'] = -0.001,
      ['str'] = 'lua,{}',
    }
  }
}
\end{minted}
\end{center}

\vfill

\strut

\newpage

\tableofcontents

\newpage

\section{Introduction}

\noindent
|luakeys| is a Lua module that can parse key-value options like the
\TeX{} packages \href{https://www.ctan.org/pkg/keyval}{keyval},
\href{https://www.ctan.org/pkg/kvsetkeys}{kvsetkeys},
\href{https://www.ctan.org/pkg/kvoptions}{kvoptions},
\href{https://www.ctan.org/pkg/xkeyval}{xkeyval},
\href{https://www.ctan.org/pkg/pgfkeys}{pgfkeys} etc. do. |luakeys|,
however, accomplishes this task entirely, by using the Lua language and
doesn’t rely on \TeX{}. Therefore this package can only be used with the
\TeX{} engine Lua\TeX{}. Since |luakeys| uses
\href{http://www.inf.puc-rio.br/~roberto/lpeg/}{LPeg}, the parsing
mechanism should be pretty robust.

The TUGboat article
\href{http://www.tug.org/tugboat/tb30-1/tb94wright-keyval.pdf}
{“Implementing key–value input: An introduction” (Volume 30 (2009), No. 1)}
by Joseph Wright and Christian Feuersänger gives a good overview of the
available key-value packages.

This package would not be possible without the article
\href{https://tug.org/TUGboat/tb40-2/tb125menke-lpeg.pdf}
{“Parsing complex data formats in LuaTEX with LPEG” (Volume 40 (2019), No. 2)}.

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\clearpage

\section{Usage}

%%
%
%%

\subsection{Using the Lua module \texttt{luakeys.lua}}

The core functionality of this package is realized in Lua. So you can
use \texttt{luakeys} without using the wrapper \TeX{} files
\texttt{luakeys.sty} and \texttt{luakeys.tex}.

\begin{minted}{latex}
\documentclass{article}
\directlua{
  luakeys = require('luakeys')
}

\newcommand{\helloworld}[2][]{
  \directlua{
    local keys = luakeys.parse('\luaescapestring{\unexpanded{#1}}')
    luakeys.debug(keys)
    local marg = '#2'
    tex.print(keys.greeting .. ', ' .. marg .. keys.punctuation)
  }
}
\begin{document}
\helloworld[greeting=hello,punctuation=!]{world}
\end{document}
\end{minted}

%%
%
%%

\subsection{Using the Lua\LaTeX{} wrapper \texttt{luakeys.sty}}

The supplied Lua\LaTeX{} file is quite small:

\begin{minted}{latex}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{luakeys}
\directlua{luakeys = require('luakeys')}
\end{minted}

\noindent
It loads the Lua module into the global variable \texttt{luakeys}.

\begin{minted}{latex}
\documentclass{article}
\usepackage{luakeys}

\begin{document}
  \directlua{
    local keys = luakeys.parse('one,two,three', { naked_as_value = true })
    tex.print(keys[1])
    tex.print(keys[2])
    tex.print(keys[3])
  }
\end{document}
\end{minted}

%%
%
%%

\subsection{Using the plain Lua\TeX{} wrapper \texttt{luakeys.tex}}

Even smaller is the file \texttt{luakeys.tex}. It consists of only one
line:

\begin{minted}{latex}
\directlua{luakeys = require('luakeys')}
\end{minted}

\noindent
It does the same as the Lua\LaTeX{} wrapper and loads the Lua module
\texttt{luakeys.lua} into the global variable \texttt{luakeys}.

\begin{minted}{latex}
\input luakeys.tex

\directlua{
  local keys = luakeys.parse('one,two,three', { naked_as_value = true })
  tex.print(keys[1])
  tex.print(keys[2])
  tex.print(keys[3])
}
\bye
\end{minted}

\section{Exported functions of the Lua module \texttt{luakeys.lua}}

To learn more about the individual functions (local functions), please
read the \href{https://josef-friedrich.github.io/luakeys/}{source code
documentation}, which was created with
\href{http://stevedonovan.github.io/ldoc/}{LDoc}. The Lua module exports
this functions:

\begin{minted}{lua}
local luakeys = require('luakeys')
local stringify = luakeys.stringify
local parse = luakeys.parse
local render = luakeys.render
local debug = luakeys.debug
local save = luakeys.save
local get = luakeys.get
local is = luakeys.is
\end{minted}

%%
%
%%

\subsection{\texttt{parse(kv\_string, options)}: table}
\label{parse}

The function \lua{parse(kv_string, options)} parses a key-value string
into a Lua table.

\begin{minted}{latex}
\newcommand{\mykeyvalcmd}[2][]{
  \directlua{
    result = luakeys.parse('#1')
    luakeys.debug(result)
  }
  #2
}
\mykeyvalcmd[one=1]{test}
\end{minted}

\noindent
In plain \TeX:

\begin{minted}{latex}
\def\mykeyvalcommand#1{
  \directlua{
    result = luakeys.parse('#1')
    luakeys.debug(result)
  }
}
\mykeyvalcmd{one=1}
\end{minted}

\noindent
The \lua{parse} function can be called with an options table. This
options are supported:

% Update also in README.md
\begin{minted}{lua}
local options = {
  -- { KEY = 'Value' } -> { key = 'value' }
  case_insensitive_keys = false,

  -- Visit all key-value pairs in the recursive parse tree.
  converter = function(key, value, depth, current_tree, root_tree)
    return key, value
  end,

  -- Automatically convert dimensions into scaled points (1cm -> 1864679).
  -- default: false
  convert_dimensions = false,

  -- Print the result table to the console.
  debug = false,

  -- The default value for naked keys (keys without a value).
  default = true

  -- A table with some default values. The result table is merged with
  -- this table.
  defaults = { key = 'value' },

  -- Key-value pair defintions.
  definitions = { key = { default = 'value' } },

  -- If true, naked keys are converted to values:
  -- { one = true, two = true, three = true } -> { 'one', 'two', 'three' }
  naked_as_value = false,

  -- Throw no error if there are unknown keys.
  no_error = false,

  -- { key = { 'value' } } -> { key = 'value' }
  unpack_single_array_value = false,
}
local result = luakeys.parse('one,two,three', options)
\end{minted}

\noindent
The options can also be set globally using the exported table
|default_options|:

\begin{minted}{lua}
luakeys.parse('dim=1cm') -- {dim = 1864679}
luakeys.default_options.convert_dimensions = false
-- or:
-- local defaults = luakeys.default_options
-- defaults.convert_dimensions = false
luakeys.parse('dim=1cm') -- {dim = '1cm'}
\end{minted}

%%
%
%%

\subsubsection{\texttt{convert\_dimensions}}

If you set the option \lua{convert_dimensions} to \lua{true}, |luakeys|
detects the \TeX{} dimensions and converts them into scaled points using
the function \lua{tex.sp(dim)}.

\InputLuaExample[firstline=4,lastline=7]{options/convert-dimensions.lua}

\noindent
By default the dimensions are not converted into scaled points.

\InputLuaExample[firstline=13,lastline=18]{options/convert-dimensions.lua}

\noindent
If you want to convert a scale point into a unit string you can use the module
\href{https://raw.githubusercontent.com/latex3/lualibs/master/lualibs-util-dim.lua}{lualibs-util-dim.lua}.

\begin{minted}{lua}
require('lualibs')
tex.print(number.todimen(tex.sp('1cm'), 'cm', '%0.0F%s'))
\end{minted}

%%
%
%%

\subsubsection{\texttt{debug}}

If the option “debug” is set to ture, the result table is printed to the
console.

\begin{minted}{latex}
\documentclass{article}
\usepackage{luakeys}
\begin{document}
\directlua{
  luakeys.parse('one,two,three', { debug = true })
}
debug
\end{document}
\end{minted}

\begin{verbatim}
This is LuaHBTeX, Version 1.15.0 (TeX Live 2022)
...
(./debug.aux) (/usr/local/texlive/texmf-dist/tex/latex/base/ts1cmr.fd)
{
  ['three'] = true,
  ['two'] = true,
  ['one'] = true,
}
 [1{/usr/
local/texlive/2022/texmf-var/fonts/map/pdftex/updmap/pdftex.map}] (./debug.aux)
)
...
Transcript written on debug.log.
\end{verbatim}

%%
%
%%

\subsubsection{\texttt{default}}
\label{option-default}

The option \lua{default} can be used to specify which value naked keys
(keys without a value) get. This option has no influence on keys with
values. By default, naked keys get the value \lua{true}.

\begin{minted}{lua}
local result = luakeys.parse('naked', { default = 1 })
luakeys.debug(result) -- { naked = 1 }
\end{minted}

\begin{minted}{lua}
local result = luakeys.parse('naked')
luakeys.debug(result) -- { naked = true }
\end{minted}

%%
%
%%

\subsubsection{\texttt{defaults}}
\label{options-defaults}

% Mit der Option „defaults“ kann nicht nur ein einiger Standardwert
% angegeben werden, sondern eine ganze Tabelle mit Standardwerten.
The option “defaults” can be used to specify not only one default value,
but a whole table of default values.
% Die Ergebnistabelle wird mit der Tabelle bestehend aus Standardwerten
% vereinigt.
The result table is merged into the defaults table.
% Werte aus der Tabelle mit Standardwerten werden von Werten der
% Ergebnistabelle überschrieben.
Values in the defaults table are
overwritten by values in the result table.

\begin{minted}{lua}
local result = luakeys.parse('key1=new', {
  defaults = { key1 = 'default', key2 = 'default' },
})
luakeys.debug(result) -- { key1 = 'new', key2 = 'default' }
\end{minted}

%%
%
%%

\subsubsection{\texttt{definitions}}

% Für mehr Information wie Schlüssel definiert werden, lesen sie das
% kapitel 3.2
For more informations on how keys are defined, see section \ref{define}.
% Wenn sie die Option \lua{definitions} verwenden, können sie auf den
% Aufruf der Funktion \lua{define} verzichten.
If you use the \lua{definitions} option, you don't need to call the
\lua{define} function.

Instead of ...

\begin{minted}{lua}
local parse = luakeys.define({
  one = { default = 1 },
  two = { default = 2 },
})
parse('one,two') -- { one = 1, two = 2 }
\end{minted}

\noindent
we can write ...

\begin{minted}{lua}
local result = luakeys.parse('one,two', {
  defintions = {
    one = { default = 1 },
    two = { default = 2 },
  }
}) -- { one = 1, two = 2 }
\end{minted}

%%
%
%%

\subsubsection{\texttt{naked\_as\_value}}

% Mit Hilfe der Optionen naked_as_value werden nackte Schlüssel nicht
% mit einem Standardwert versehen, sondern als Werte in die Lua-Tabelle
% abgelegt.
With the help of the option \lua{naked_as_value}, naked keys are not
given a default value, but are stored as values in a Lua table.

% test-public-functions.lua Function “parse()” / Options / Option “naked_as_value”'
\begin{minted}{lua}
local result = luakeys.parse('one,two,three')
luakeys.debug(result) -- { one = true, two = true, three = true }
\end{minted}

\noindent
If we set the option \lua{naked_as_value} to \lua{true}:

\begin{minted}{lua}
local result = luakeys.parse('one,two,three', { naked_as_value = true })
luakeys.debug(result)
-- { [1] = 'one', [2] = 'two', [3] = 'three' }
-- { 'one', 'two', 'three' }
\end{minted}

%%
%
%%

\subsubsection{\texttt{no\_error}}

% Standardmaßig wirft parse-Funktion einen Fehler, wenn es unbekannte
% Schlüssel gibt.
By default the parse function throws an error if there are unknown keys.
% Mit Hilfe der Option \lua{no_error} kann dies unterbunden werden.
This can be prevented with the help of the \lua{no_error} option.

\begin{minted}{lua}
luakeys.parse('unknown', { definitions = { 'key' } })
-- Error message: Unknown keys: unknown,
\end{minted}

\noindent
If we set the option \lua{no_error} to \lua{true}:

\begin{minted}{lua}
luakeys.parse('unknown', { definitions = { 'key' }, no_error = true })
-- No error message
\end{minted}

%%
%
%%

\subsection{\texttt{define(defintions, options)}}
\label{define}

The \lua{define} function returns a \lua{parse} function (see
\ref{parse}).
The name of a key can be specified in three ways:

\begin{enumerate}
\item as a string.
\item as a key in a Lua table. The definition of the corresponding
key-value pair is then stored under this key.
\item by the “name” option.
\end{enumerate}

\begin{minted}{lua}
-- standalone string values
local defintions = { 'key' }

-- keys in a Lua table
local defintions = { key = { ... } }

-- by the “name” option
local defintions = { { name = 'key', ... } }

local parse = luakeys.define(defintions)
local result, leftover = parse(
  'key=value,unknown=unknown',
  { no_error = true }
)
luakeys.debug(result) -- { key = 'value' }
luakeys.debug(leftover) -- { unknown = 'unknown' }
\end{minted}

\noindent
For nested definitions, only the last two ways of specifying the key
names can be used.

\begin{minted}{lua}
local parse = luakeys.define({
  level1 = { sub_keys = { level2 = { sub_keys = { key = { some_def = 'etc' } } } } },
})
local result, leftover = parse('level1={level2={key=value,unknown=unknown}}')
luakeys.debug(result) -- { level1 = { level2 = { key = 'value' } } })
luakeys.debug(leftover) -- { level1 = { level2 = { unknown = 'unknown' } } })
\end{minted}

The code example below lists all the settings that can be used to define
key-value pairs.

\begin{minted}{lua}
local defintions = {
  key = {
    -- Allow different key names.
    -- or a single string: alias = 'k'
    alias = { 'k', 'ke' },

    -- The key is always included in the result. If no default value is
    -- definied, true is taken as the value.
    always_present = false,

    -- Only values listed in the array table are allowed.
    choices = { 'one', 'two', 'three' },

    -- Possible data types: boolean, dimension, integer, number, string
    data_type = 'string',

    default = true,

    -- The key belongs to a mutually exclusive group of keys.
    exclusive_group = 'name',

    -- > \g_my_token_list_tl
    l3_tl_set = 'my_token_list',

    -- > \MacroName
    macro = 'MacroName', -- > \MacroName

    -- See http://www.lua.org/manual/5.3/manual.html#6.4.1
    match = '^%d%d%d%d%-%d%d%-%d%d$',

    -- name of the key, can be omitted
    name = 'key',
    opposite_keys = { [true] = 'show', [false] = 'hide' },
    process = function(value, result, leftover)
      return value
    end,
    required = true,
    sub_keys = { key_level_2 = { ... } },
  }
}
\end{minted}

%%
%
%%

\subsubsection{\texttt{alias}}

With the help of the \lua{alias} option, other key names can be used.
The value is always stored under the original key name. A single alias
name can be specified by a string ...

\InputLuaExample[firstline=4,lastline=7]{definitions/options/alias.lua}

\noindent
multiple aliases by a list of strings.

\InputLuaExample[firstline=13,lastline=16]{definitions/options/alias.lua}

%%
%
%%

\subsubsection{\texttt{always\_present}}

% Die Option \lua{default} wird nur bei nackten Schlüsseln verwendet.
The \lua{default} option is used only for naked keys.

\InputLuaExample[firstline=4,lastline=5]{definitions/options/always-present.lua}

\noindent
% Wird die Option \lua{always_present} auf wahr gesetzt, wird der
% Schlüssel immer ins Ergebnis mit übernommen.
If the option \lua{always_present} is set to true, the key is always
included in the result. If no default value is definied, true is taken
as the value.

\InputLuaExample[firstline=11,lastline=12]{definitions/options/always-present.lua}

%%
%
%%

\subsubsection{\texttt{choices}}

\InputLuaExample[firstline=4,lastline=5]{definitions/options/choices.lua}

\InputLuaExample[firstline=13,lastline=15]{definitions/options/choices.lua}

%%
%
%%

\subsubsection{\texttt{data\_type}}

\InputLuaExample[firstline=4,lastline=8]{definitions/options/data-type.lua}
\InputLuaExample[firstline=11,lastline=15]{definitions/options/data-type.lua}

%%
%
%%

\subsubsection{\texttt{default}}

% Verwenden Sie die Option „\lua{default}“, um für jeden nackten Schlüssel
% einzeln einen Standardwert bereit zu stellen.
Use the \lua{default} option to provide a default value for each naked
key individually.
%
% Mit der globalen \lua{default} Option kann für alle nackten Schlüssel ein
% Standardwert vorgegeben werden.
With the global \lua{default} option (\ref{option-default}) a default
value can be specified for all naked keys.

\InputLuaExample[firstline=4,lastline=9]{definitions/options/default.lua}

%%
%
%%

\subsubsection{\texttt{exclusive\_group}}

% Alle Schlüssel, die der gleichen ausschließenden Gruppe angehören,
% dürfen nicht gemeinsam angegeben werden.
All keys belonging to the same exclusive group must not be specified
together.
%
% Nur ein Schlüssel aus dieser Gruppe ist erlaubt.
Only one key from this group is allowed.
%
% Als Name für diese ausschließende Gruppe kann irgend ein beliebiger
% Wert verwendet werden.
Any value can be used as a name for this exclusive group.

\InputLuaExample[firstline=4,lastline=9]{definitions/options/exclusive-group.lua}

% Werden mehrer Schlüssel der Gruppe angegeben, so wird eine
% Fehlermeldung geworfen.
If more than one key of the group is specified, an error message is
thrown.

\InputLuaExample[firstline=21,lastline=23]{definitions/options/exclusive-group.lua}

%%
%
%%

\subsubsection{\texttt{opposite\_keys}}

% Die Option \lua{opposite_keys} ermöglicht es, gegensätzliche (nackte)
% Schlüssel in Wahrheitswerte umzuwandeln und diesen Wahrheitswert unter
% einem Zielschlüssel zu speichern.
The \lua{opposite_keys} option allows to convert opposite (naked) keys
into a boolean value and store this boolean under a target key.
%
% Lua erlaubt es in Tabellen Wahrheitswerte als Schlüssel zu verwenden.
% Es müssen jedoch eckige Klammern verwendet werden.
Lua allows boolean values to be used as keys in tables.
%
% Die Wahrheitswerte müssen jedoch in eckige Klammern geschrieben werden.
However, the boolean values must be written in square brackets, e. g.
\lua{{ opposite_keys = { [true] = 'show', [false] = 'hide' } }}.
%
% Beispiele für gegensätzliche Schlüssel sind:
Examples of opposing keys are: \lua{show} and \lua{hide}, \lua{dark} and
\lua{light}, \lua{question} and \lua{solution}.
%
% Das untenstehende Beispiel verwendet als gegensätzliches Schlüsselpaar
% die Schlüssel \lua{show} und \lua{hide}.
The example below uses the \lua{show} and \lua{hide} keys as the
opposite key pair.
%
% Wird der Schlüssel \lua{show} von der Funktion \lua{parse} gelesen,
% dann erhält der Zielschlüssel \lua{visibility} den Wert \lua{true}.
If the key \lua{show} is parsed by the \lua{parse} function, then the
target key \lua{visibility} receives the value \lua{true}.

\InputLuaExample[firstline=4,lastline=7]{definitions/options/opposite-keys.lua}

% Wird der Schlüssel \lua{hide} gelesen, dann \lua{falsch}.
\noindent
If the key \lua{hide} is parsed, then \lua{false}.

\InputLuaExample[firstline=13,lastline=13]{definitions/options/opposite-keys.lua}

%%
%
%%

\subsubsection{\texttt{macro}}

The option \texttt{macro} stores the value in a \TeX{} macro.

\begin{minted}{lua}
local parse = luakeys.define({
  key = {
    macro = 'MyMacro'
  }
})
parse('key=value')
\end{minted}

\begin{minted}{latex}
\MyMacro % expands to “value”
\end{minted}

%%
%
%%

\subsubsection{\texttt{match}}

% Der Wert des Schlüssel wird der Lua Funktion übergeben
The value of the key is passed to the Lua function
\lua{string.match(value, match)} ((\url{http://www.lua.org/manual/5.3/manual.html#pdf-string.match})).
% Werfe einen Blick in das Lua-Handbuch, wie man Patterns schreibt.
Take a look at the Lua manual on how to write patterns
(\url{http://www.lua.org/manual/5.3/manual.html#6.4.1})

\InputLuaExample[firstline=4,lastline=6]{definitions/options/match.lua}

\noindent
% Kann das Pattern im Wert nicht gefunden werden, wird eine
% Fehlermeldung ausgegeben.
If the pattern cannot be found in the value, an error message is issued.

\InputLuaExample[firstline=14,lastline=17]{definitions/options/match.lua}

\noindent
% Der Schlüssel erhält das Ergebnis der Funktion \lua{string.match(value,
% match)}, dass bedeutet, dass der ursprüngliche Wert unter
% Umständen nicht vollständig in den Schlüssel gespeichert wird.
The key receives the result of the function \lua{string.match(value,
match)}, which means that the original value may not be stored
completely in the key.

\InputLuaExample[firstline=22,lastline=23]{definitions/options/match.lua}

\noindent
% Das Präfix “waste ” und das Suffix “ rubbisch” der Zeichenketten wird
% verworfen.
The prefix “waste ” and the suffix “ rubbisch” of the string are
discarded.

\InputLuaExample[firstline=29,lastline=29]{definitions/options/match.lua}

\noindent
% Da Funktion \lua{string.match(value, match)} immer eine Zeichenkette
% zurückgibt, ist der Wert des Schlüssel auch immer eine Zeichenkette.
Since function \lua{string.match(value, match)} always returns a string,
the value of the key is also always a string.

%%
%
%%

\subsubsection{\texttt{name}}

% Die Option \lua{name} ermöglicht eine alternative Notation von
% Schlüsselnamen.
The \lua{name} option allows an alternative notation of key names.
%
% Anstatt ...
Instead of ...

\InputLuaExample[firstline=4,lastline=5]{definitions/options/name.lua}

\noindent
% ... können wir schreiben:
... we can write:

\InputLuaExample[firstline=11,lastline=15]{definitions/options/name.lua}

%%
%
%%

\subsubsection{\texttt{process}}

The \lua{process} option can be used to define a function whose return
value is passed to the key. Four parameters are passed when the
function is called:

\begin{enumerate}
\item \lua{value}:
% Der zum schlüssel gehörende aktuelle Wert.
The current value asssociated with the key.
\item \lua{input}:
% Die Ergebnis-Tabelle, die vor dem Zeitpunkt geklont wurde, als mit dem
% Anwenden der Definitionen begonnen wurde.
The result table cloned before the time the definitions started to be applied.
\item \lua{result}: The table in which the final result will be saved.
\item \lua{unknown}: The table in which the leftover key-value pairs
are stored.
\end{enumerate}

% Das folgende Beispiel demonstriert den Parameter \lua{value}.
\noindent
The following example demonstrates the \lua{value} parameter:
\InputLuaExample[firstline=4,lastline=14]{definitions/options/process.lua}

\noindent
The following example demonstrates the \lua{input} parameter:

\InputLuaExample[firstline=22,lastline=34]{definitions/options/process.lua}

\noindent
The following example demonstrates the \lua{result} parameter:

\InputLuaExample[firstline=42,lastline=50]{definitions/options/process.lua}

\noindent
The following example demonstrates the \lua{unknown} parameter:

\InputLuaExample[firstline=58,lastline=65]{definitions/options/process.lua}
\InputLuaExample[firstline=69,lastline=69]{definitions/options/process.lua}

%%
%
%%

\subsubsection{\texttt{required}}

\InputLuaExample[firstline=4,lastline=5]{definitions/options/required.lua}

\InputLuaExample[firstline=13,lastline=14]{definitions/options/required.lua}

\noindent
A recursive example:

\InputLuaExample[firstline=18,lastline=23]{definitions/options/required.lua}
\InputLuaExample[firstline=29,lastline=30]{definitions/options/required.lua}
\InputLuaExample[firstline=38,lastline=39]{definitions/options/required.lua}

%%
%
%%

\subsubsection{\texttt{sub\_keys}}

% Mit der Option \lua{sub_keys} können ineinander verschachtelte
% Schlüssel-Wert-Paar-Definitionen aufgebaut werden.
The \lua{sub_keys} option can be used to build nested key-value pair
definitions.

\InputLuaExample[firstline=4,lastline=16]{definitions/options/sub-keys.lua}

%%
%
%%

\subsection{\texttt{render(tbl)}: string}

The function \lua{render(tbl)} reverses the function
\lua{parse(kv_string)}. It takes a Lua table and converts this table
into a key-value string. The resulting string usually has a different
order as the input table.

\InputLuaExample[firstline=4,lastline=10]{functions/render.lua}

\noindent
In Lua only tables with 1-based consecutive integer keys (a.k.a. array
tables) can be parsed in order.

\InputLuaExample[firstline=16,lastline=17]{functions/render.lua}

%%
%
%%

\subsection{\texttt{debug(tbl): void}}

The function \lua{debug(tbl)} pretty prints a Lua table to standard
output (stdout). It is a utility function that can be used to debug and
inspect the resulting Lua table of the function \lua{parse}. You have to
compile your \TeX{} document in a console to see the terminal output.

\InputLuaExample[firstline=4,lastline=5]{functions/debug.lua}

\noindent
The output should look like this:

\begin{minted}{md}
{
  ['level1'] = {
      ['level2'] = {
        ['key'] = 'value',
    },
  }
}
\end{minted}

%%
%
%%

\subsection{\texttt{save(identifier, result): void}}

The function \lua{save(identifier, result)} saves a result (a
table from a previous run of \lua{parse}) under an identifier.
Therefore, it is not necessary to pollute the global namespace to
store results for the later usage.

%%
%
%%

\subsection{\texttt{get(identifier): table}}

The function \lua{get(identifier)} retrieves a saved result from the
result store.

%%
%
%%

\subsection{\texttt{is}}

\subsubsection{\texttt{is.boolean(value): boolean}}
\InputLuaExample[firstline=7,lastline=23]{is-table.lua}

\subsubsection{\texttt{is.dimension(value): boolean}}
\InputLuaExample[firstline=27,lastline=37]{is-table.lua}

\subsubsection{\texttt{is.integer(value): boolean}}
\InputLuaExample[firstline=41,lastline=46]{is-table.lua}

\subsubsection{\texttt{is.number(value): boolean}}
\InputLuaExample[firstline=50,lastline=57]{is-table.lua}

\subsubsection{\texttt{is.string(value): boolean}}
\InputLuaExample[firstline=61,lastline=67]{is-table.lua}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Syntax of the recognized key-value format}

%%
%
%%

\subsection{An attempt to put the syntax into words}

A key-value pair is definied by an equal sign (\texttt{key=value}).
Several key-value pairs or keys without values (naked keys) are lined up
with commas (\texttt{key=value,naked}) and build a key-value list. Curly
brackets can be used to create a recursive data structure of nested
key-value lists (\texttt{level1=\{level2=\{key=value,naked\}\}}).

%%
%
%%

\subsection{An (incomplete) attempt to put the syntax into the Extended Backus-Naur Form}

\begin{grammar}
<list> ::= \{ <list-item> \}

<list-container> ::= `{' <list> `}'

<list-item> ::= ( <list-container> | <key-value-pair> | <value> ) [ `,' ]

<key-value-pair> ::= <value> `=' ( <list-container> | <value> )

<value> ::= <boolean>
  \alt <dimension>
  \alt <number>
  \alt <string-quoted>
  \alt <string-unquoted>

<dimension> ::= <number> <unit>

<number> ::= <sign> ( <integer> [ <fractional> ] | <fractional> )

<fractional> ::= `.' <integer>

<sign> ::= `-' | `+'

<integer> ::= <digit> \{ <digit> \}

<digit> ::= `0' | `1' | `2' | `3' | `4' | `5' | `6' | `7' | `8' | `9'

<unit> ::= `bp' | `BP'
  \alt `cc' | `CC'
  \alt `cm' | `CM'
  \alt `dd' | `DD'
  \alt `em' | `EM'
  \alt `ex' | `EX'
  \alt `in' | `IN'
  \alt `mm' | `MM'
  \alt `nc' | `NC'
  \alt `nd' | `ND'
  \alt `pc' | `PC'
  \alt `pt' | `PT'
  \alt `sp' | `SP'

<boolean> ::= <boolean-true> | <boolean-false>

<boolean-true> ::= `true' | `TRUE' | `True'

<boolean-false> ::= `false' | `FALSE' | `False'
\end{grammar}

... to be continued

%%
%
%%

\subsection{Recognized data types}

\subsubsection{boolean}

The strings \texttt{true}, \texttt{TRUE} and \texttt{True} are converted
into Lua’s boolean type \lua{true}, the strings \texttt{false},
\texttt{FALSE} and \texttt{False} into \lua{false}.

\begin{multicols}{2}
\begin{minted}{latex}
\luakeysdebug{
  lower case true = true,
  upper case true = TRUE,
  title case true = True
  lower case false = false,
  upper case false = FALSE,
  title case false = False,
}
\end{minted}
\begin{minted}{lua}
{
  ['lower case true'] = true,
  ['upper case true'] = true,
  ['title case true'] = true,
  ['lower case false'] = false,
  ['upper case false'] = false
  ['title case false'] = false,
}
\end{minted}
\end{multicols}

%%
%
%%

\subsubsection{number}

\begin{multicols}{2}
\begin{minted}{latex}
\luakeysdebug{
  num1 = 4,
  num2 = -4,
  num3 = 0.4
}
\end{minted}
\begin{minted}{lua}
{
  ['num1'] = 4,
  ['num2'] = -4,
  ['num3'] = 0.4
}
\end{minted}
\end{multicols}

%%
%
%%

\subsubsection{dimension}

\begin{center}
\begin{tabular}{rl}
\textbf{Unit name} & \textbf{Description} \\\hline
bp & big point \\
cc & cicero \\
cm & centimeter \\
dd & didot \\
em & horizontal measure of \emph{M} \\
ex & vertical measure of \emph{x} \\
in & inch \\
mm & milimeter \\
nc & new cicero \\
nd & new didot \\
pc & pica \\
pt & point \\
sp & scaledpoint \\
\end{tabular}
\end{center}

\begin{multicols}{2}
\begin{minted}{latex}
\luakeysdebug{
  bp = 1bp,
  cc = 1cc,
  cm = 1cm,
  dd = 1dd,
  em = 1em,
  ex = 1ex,
  in = 1in,
  mm = 1mm,
  nc = 1nc,
  nd = 1nd,
  pc = 1pc,
  pt = 1pt,
  sp = 1sp,
}
\end{minted}
\begin{minted}{lua}
{
  ['bp'] = 65781,
  ['cc'] = 841489,
  ['cm'] = 1864679,
  ['dd'] = 70124,
  ['em'] = 655360,
  ['ex'] = 282460,
  ['in'] = 4736286,
  ['mm'] = 186467,
  ['nc'] = 839105,
  ['nd'] = 69925,
  ['pc'] = 786432,
  ['pt'] = 65536,
  ['sp'] = 1,
}
\end{minted}
\end{multicols}

%%
%
%%

\subsubsection{string}

There are two ways to specify strings: With or without quotes. If the
text have to contain commas or equal signs, then double quotation
marks must be used.

\begin{multicols}{2}
\begin{minted}{latex}
\luakeysdebug{
  without quotes = no commas and equal signs are allowed,
  with double quotes = ", and = are allowed",
}
\end{minted}
\begin{minted}{lua}
{
  ['without quotes'] = 'no commas and equal signs are allowed',
  ['with double quotes'] = ', and = are allowed',
}
\end{minted}
\end{multicols}

\subsubsection{Standalone values}

Standalone values are values without a key. They are converted into an
array. In Lua an array is a table with numeric indexes (The first index
is 1).

\begin{multicols}{2}
\begin{minted}{latex}
\luakeysdebug{one,two,three}
\end{minted}
\columnbreak
\begin{minted}{lua}
{ 'one', 'two', 'three' }
\end{minted}

\noindent
is equivalent to

\begin{minted}{lua}
{
  [1] = 'one',
  [2] = 'two',
  [3] = 'three',
}
\end{minted}
\end{multicols}

\noindent
All recognized data types can be used as standalone values.

\begin{multicols}{2}
\begin{minted}{latex}
\luakeysdebug{one,2,3cm}
\end{minted}
\columnbreak
\begin{minted}{lua}
{ 'one', 2, 5594039 }
\end{minted}
\end{multicols}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\clearpage

\section{Examples}

\subsection{Extend and modify keys of existing macros}

Extend the includegraphics macro with a new key named \latex{caption}
and change the accepted values of the \latex{width} key. A number
between 0 and 1 is allowed and converted into
\latex{width=0.5\linewidth}

\InputLuaExample{extend-includegraphics/extend-keys.lua}
\InputLatexExample{extend-includegraphics/extend-keys.tex}

\subsection{Process document class options}

\begin{minted}{latex}
\directlua{luakeys.parse('\@classoptionslist')}
\end{minted}

\InputLatexExample{class-options/test-class.cls}
\InputLatexExample{class-options/use-test-class.tex}

\begin{minted}{lua}
{
  [1] = '12pt',
  [2] = 'landscape',
}
\end{minted}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\clearpage

\section{Debug packages}

Two small debug packages are included in |luakeys|. One debug package
can be used in \LaTeX{} (luakeys-debug.sty) and one can be used in plain
\TeX{} (luakeys-debug.tex). Both packages provide only one command:
|\luakeysdebug{kv-string}|

\begin{minted}{latex}
\luakeysdebug{one,two,three}
\end{minted}

\noindent
Then the following output should appear in the document:
\bigskip

\luakeysdebug{one,two,three}

%%
%
%%

\subsection{For plain \TeX: luakeys-debug.tex}

An example of how to use the command in plain \TeX:

\begin{minted}{latex}
\input luakeys-debug.tex
\luakeysdebug{one,two,three}
\bye
\end{minted}

%%
%
%%

\subsection{For \LaTeX: luakeys-debug.sty}

An example of how to use the command in \LaTeX:

\begin{minted}{latex}
\documentclass{article}
\usepackage{luakeys-debug}
\begin{document}
\luakeysdebug[
  unpack single array values=false,
  convert dimensions=false
]{one,two,three}
\end{document}
\end{minted}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\clearpage

\section{Implementation}

%%
%
%%

\subsection{luakeys.lua}

\inputminted[linenos=true]{lua}{luakeys.lua}

%%
%
%%

\clearpage

\subsection{luakeys.tex}

\inputminted[linenos=true]{latex}{luakeys.tex}

%%
%
%%

\clearpage

\subsection{luakeys.sty}

\inputminted[linenos=true]{latex}{luakeys.sty}

%%
%
%%

\clearpage

\subsection{luakeys-debug.tex}

\inputminted[linenos=true]{latex}{luakeys-debug.tex}

%%
%
%%

\clearpage

\subsection{luakeys-debug.sty}

\inputminted[linenos=true]{latex}{luakeys-debug.sty}

\changes{v0.1}{2021/01/18}{Inital release}
\changes{v0.2}{2021/09/19}{
* Allow all recognized data types as keys
* Allow TeX macros in the values
* New public Lua functions: save(identifier, result), get(identifier)
}
\changes{v0.3}{2021/11/05}{
* Add a LuaLaTeX wrapper “luakeys.sty”
* Add a plain LuaTeX wrapper “luakeys.tex”
* Rename the previous documentation file “luakeys.tex” to luakeys-doc.tex”
}
\changes{v0.4}{2021/12/31}{
* Parser: Add support for nested tables (for example {{'a', 'b'}})
* Parser: Allow only strings and numbers as keys
* Parser: Remove support from Lua numbers with exponents (for example '5e+20')
* Switch the Lua testing framework to busted
}
\changes{v0.5}{2022/04/04}{
* Add possibility to change options globally
* New option: standalone\_as\_true
* Add a recursive converter callback / hook to process the parse tree
* New option: case\_insensitive\_keys
}
\changes{v0.6}{2022/05/29}{
* The default value of the option “convert\_dimension” is now false.
* The function “print” is now called “debug”.
* The option “standalone\_as\_true” is renamed to “naked\_as\_value”. The
  boolean value of the option must be changed to the opposite to
  produce the previous effect.
}
\pagebreak
\PrintChanges
\pagebreak
\PrintIndex
\end{document}
