\documentclass{ltxdoc}

\usepackage[
  colorlinks=true,
  linkcolor=blue,
  filecolor=blue,
  urlcolor=blue,
]{hyperref}
\EnableCrossrefs
\CodelineIndex
\RecordChanges

\usepackage{mdframed}
\usepackage{minted}
\usepackage{luakeys-debug}
\usepackage{multicol}
\usepackage{luacode}
\usepackage{syntax}
\usemintedstyle{friendly}
\BeforeBeginEnvironment{minted}{\begin{mdframed}}
\AfterEndEnvironment{minted}{\end{mdframed}}
\setminted{
  breaklines=true,
  fontsize=\footnotesize,
}
\def\lua#1{\mintinline{lua}|#1|}

\begin{document}

\providecommand*{\url}{\texttt}

\title{The \textsf{luakeys} package}
\author{%
  Josef Friedrich\\%
  \url{josef@friedrich.rocks}\\%
  \href{https://github.com/Josef-Friedrich/nodetree}{github.com/Josef-Friedrich/luakeys}%
}
\date{v0.1 from 2021/01/10}

\maketitle

\vfill

%\luakeysdebug{level1={level2={level3={dim=1cm,bool=true,num=-1e-03,str=lua}}}}

\begin{minted}{lua}
local luakeys = require('luakeys')
local kv = luakeys.parse('level1={level2={level3={dim=1cm,bool=true,num=-1e-03,str=lua}}}')
luakeys.print(kv)
\end{minted}

\noindent
Result:

\begin{center}
\begin{minted}{lua}
{
  ['level1'] = {
    ['level2'] = {
      ['level3'] = {
        ['dim'] = 1864679,
        ['bool'] = true,
        ['num'] = -0.001
        ['str'] = 'lua',
      }
    }
  }
}
\end{minted}
\end{center}

\vfill

\strut

\newpage

\tableofcontents

\newpage

\section{Introduction}

\noindent
|luakeys| is a Lua module that can parse key-value options like the
\TeX{} packages \href{https://www.ctan.org/pkg/keyval}{keyval},
\href{https://www.ctan.org/pkg/kvsetkeys}{kvsetkeys},
\href{https://www.ctan.org/pkg/kvoptions}{kvoptions},
\href{https://www.ctan.org/pkg/xkeyval}{xkeyval},
\href{https://www.ctan.org/pkg/pgfkeys}{pgfkeys} etc. But |luakeys|
accompilshes this task entirely using the Lua language and doesn’t rely
on \TeX{} macros. Therefore this package can only be used with the
\TeX{} engine Lua\TeX{}. Since |luakeys| uses
\href{http://www.inf.puc-rio.br/~roberto/lpeg/}{LPeg}, the parsing
mechanism should be pretty robust.

\href{http://www.tug.org/tugboat/tb30-1/tb94wright-keyval.pdf}{“Implementing key–value input: An introduction” (TUGboat, Volume 30 (2009), No. 1)}
by Joseph Wright and Christian Feuersänger

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Recognized data types}

\begin{grammar}
<list> ::= <value> | <value-without-key>

<list-elements> ::= `}'

<value> ::= <object>
  \alt <boolean>
  \alt <dimension>
  \alt <number>
  \alt <string-quoted>
  \alt <string-unquoted>

<value-without-key> ::= <dimension>
  \alt <boolean>
  \alt <number>
  \alt <string-quoted>
  \alt <string-unquoted>

<list-container> ::== `{' <list> `}'

\end{grammar}

%%
%
%%

\subsection{boolean}

\begin{multicols}{2}
\begin{minted}{latex}
\luakeysdebug{
  lower case true = true,
  upper case true = TRUE,
  title case true = True
  lower case false = false,
  upper case false = FALSE,
  title case false = False,
}
\end{minted}
\begin{minted}{lua}
{
  ['lower case true'] = true,
  ['upper case true'] = true,
  ['title case true'] = true,
  ['lower case false'] = false,
  ['upper case false'] = false
  ['title case false'] = false,
}
\end{minted}
\end{multicols}

%%
%
%%

\subsection{number}

\begin{multicols}{2}
\begin{minted}{latex}
\luakeysdebug{
  num1 = 4,
  num2 = 4,
  num3 = 0.4,
  num4 = 4.57e-3,
  num5 = 0.3e12,
  num6 = 5e+20
}
\end{minted}
\begin{minted}{lua}
{
  ['num1'] = 4,
  ['num2'] = 4,
  ['num3'] = 0.4,
  ['num4'] = 0.00457,
  ['num5'] = 300000000000.0,
  ['num6'] = 5e+20
}
\end{minted}
\end{multicols}

%%
%
%%

\subsection{dimension}

|luakeys| detects \TeX{} dimensions and automatically converts the
dimensions into scaled points using the function \lua{tex.sp(dim)}. Use
the option \lua{convert_dimensions} of the function
\lua{parse(kv_string, options)} to disalbe the automatic conversion.

\begin{minted}{lua}
local result = parse('dim=1cm', {
  convert_dimensions = false,
})
\end{minted}

If you want to convert a scale point into a unit string you can used the module
\href{https://raw.githubusercontent.com/latex3/lualibs/master/lualibs-util-dim.lua}{lualibs-util-dim.lua}.

\begin{minted}{latex}
\begin{luacode}
require('lualibs')
tex.print(number.todimen(tex.sp('1cm'), 'cm', '%0.0F%s'))
\end{luacode}
\end{minted}

\begin{tabular}{rl}
\textbf{Unit name} & \textbf{Description} \\\hline
bp & big point \\
cc & cicero \\
cm & centimeter \\
dd & didot \\
em & horizontal measure of \emph{M} \\
ex & vertical measure of \emph{x} \\
in & inch \\
mm & milimeter \\
nc & new cicero \\
nd & new didot \\
pc & pica \\
pt & point \\
sp & scaledpoint \\
\end{tabular}

\begin{multicols}{2}
\begin{minted}{latex}
\luakeysdebug{
  bp = 1bp,
  cc = 1cc,
  cm = 1cm,
  dd = 1dd,
  em = 1em,
  ex = 1ex,
  in = 1in,
  mm = 1mm,
  nc = 1nc,
  nd = 1nd,
  pc = 1pc,
  pt = 1pt,
  sp = 1sp,
}
\end{minted}
\begin{minted}{lua}
{
  ['bp'] = 65781,
  ['cc'] = 841489,
  ['cm'] = 1864679,
  ['dd'] = 70124,
  ['em'] = 655360,
  ['ex'] = 282460,
  ['in'] = 4736286,
  ['mm'] = 186467,
  ['nc'] = 839105,
  ['nd'] = 69925,
  ['pc'] = 786432,
  ['pt'] = 65536,
  ['sp'] = 1,
}
\end{minted}
\end{multicols}

%%
%
%%

\subsection{string}

There are two ways to specify strings: With or without quotes. If the
text have to contain commas or equal signs, then double quotation
marks must be used.

\begin{multicols}{2}
\begin{minted}{latex}
\luakeysdebug{
  without quotes = no commas and equal signs are allowed,
  with double quotes = ", and = are allowed",
}
\end{minted}
\begin{minted}{lua}
{
  ['without quotes'] = 'no commas and equal signs are allowed',
  ['with double quotes'] = ', and = are allowed',
}
\end{minted}
\end{multicols}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Exported functions of the Lua module \texttt{luakeys.lua}}

The Lua module exports this functions:

\begin{minted}{lua}
local luakeys = require('luakeys')
local parse = luakeys.parse
local render = luakeys.render
--local print = luakeys.print -- print is a reserved word, use luakeys.print()
local stringify = luakeys.stringify
\end{minted}

%%
%
%%

\subsection{\texttt{parse(kv\_string, options)}: table}

The function \lua{parse(input_string, options)} is the main method of
this module. It parses a key-value string into a Lua table.

\begin{minted}{latex}
\newcommand{\mykeyvalcmd}[1][]{
  \directlua{
    result = luakeys.parse('#1')
    luakeys.print(result)
  }
  #2
}
\mykeyvalcmd[one=1]{test}
\end{minted}

\noindent
In plain \TeX:

\begin{minted}{latex}
\def\mykeyvalcommand#1{
  \directlua{
    result = luakeys.parse('#1')
    luakeys.print(result)
  }
}
\mykeyvalcmd{one=1}
\end{minted}

\noindent
The function can be called with a options table. This two options are
supported.

\begin{minted}{lua}
local result = parse('one,two,three', {
  convert_dimensions = false,
  unpack_single_array_value = false
})
\end{minted}

%%
%
%%

\subsection{\texttt{render(tbl)}: string}

The function \lua{render(tbl)} works in reverse of the function
\lua{parse(lua_table)}. It takes a Lua table and converts this table
into a key-value string. The resulting string usually has a different
order as your input table.

\begin{minted}{lua}
result = luakeys.parse('one=1,two=2,tree=3,')
print(luakeys.render(result))
--- one=1,two=2,tree=3,
--- or:
--- two=2,one=1,tree=3,
--- or:
--- ...
\end{minted}

In Lua, only tables with 1-based consecutive integer keys (a.k.a. array
tables) can be parsed in order.

\begin{minted}{lua}
result = luakeys.parse('one,two,three')
print(luakeys.render(result))
--- one,two,three, (always)
\end{minted}

%%
%
%%

\subsection{\texttt{print(tbl): void}}

The function \lua{print(tbl)} pretty prints a Lua table to stdout. It is
a utility function that can be used to debug and inspect the resulting
Lua table from the parse function. You have to use a console to compile
your \TeX{} document to see the terminal output.

\begin{minted}{md}
{
  ['level1'] = {
    ['level2'] = {
      ['level3'] = {
        ['str'] = 'lua',
        ['bool'] = true,
        ['num'] = -0.001,
        ['dim'] = 1864679,
      },
    },
  },
}
\end{minted}

%%
%
%%

\subsection{\texttt{stringify(tbl, for\_tex): string}}

The function \lua{stringify(tbl, for_tex)} converts a Lua table into a
printable string. This function is used to realize the print() function
from above. \lua{stringify(tbl, true)} (\lua{for_tex = true}) generates
a string which can be embeded into \TeX{}-documents. The macro
|\luakeysdebug{}| uses this option. \lua{stringify(tbl, false)} or
\lua{stringify(tbl)} generating a string suitable for the terminal.

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Implementation}

\inputminted{lua}{luakeys.lua}

\pagebreak
\PrintChanges
\pagebreak
\PrintIndex
\end{document}
